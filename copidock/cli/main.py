import typer
from typing import Optional, Dict
from rich import print as rprint
from pathlib import Path
from datetime import datetime
from .gather import render_files_markdown 

from ..templates.loader import template_loader
from .commands.thread import thread_start
from .api import CopidockAPI, resolve_api
from ..config.config import find_repo_root, load_state, save_state, DEFAULT_PROFILE

# NEW: Import interactive functions
from ..interactive.detection import auto_detect_context
from ..interactive.flow import run_interactive_flow, confirm_snapshot_creation

app = typer.Typer(
    add_completion=False, 
    help="Copidock CLI - Serverless note management\n\nExamples:\n  copidock snapshot --hydrate\n  copidock rehydrate restore LATEST"
)

def create_rehydration_markdown(thread_data: Dict, synth_sections: Dict, file_paths: list, recent_commits: list, enhanced_context: Dict) -> str:
    created_at = datetime.utcnow().isoformat() + "Z"
    thread_slug = thread_data.get('goal', 'development-task').lower().replace(' ', '-')
    
    frontmatter = f"""---
thread_id: {thread_data.get('thread_id', '')}
thread_slug: {thread_slug}
snapshot_id: comprehensive-{datetime.utcnow().strftime('%Y%m%d-%H%M%S')}
version: 1
created_at: {created_at}
repo: {thread_data.get('repo', 'unknown')}
branch: {thread_data.get('branch', 'main')}
goal: "{thread_data.get('goal', 'development task')}"
persona: {enhanced_context.get('persona', 'senior-backend-dev')}
focus: "{enhanced_context.get('focus', '')}"
output: "{enhanced_context.get('output', '')}"
constraints: "{enhanced_context.get('constraints', '')}"
file_count: {len(file_paths)}
commit_count: {len(recent_commits)}
---

# Rehydrate: {thread_data.get('goal', 'Development Task')}

## Context Restoration
"""
    # Render all available synth sections (only strings)
    ordered_keys = [
        'operator_instructions',
        'current_state',
        'current_development_state',
        'decisions_constraints',
        'technical_approach',
        'development_priorities',
        'open_questions',
        'next_steps',
    ]
    seen = set()
    parts = []

    for k in ordered_keys:
        v = synth_sections.get(k)
        if isinstance(v, str) and v.strip():
            parts.append(v.strip())
            seen.add(k)

    for k, v in synth_sections.items():
        if k in seen:
            continue
        if isinstance(v, str) and v.strip():
            parts.append(v.strip())

    # >>> INSERTED: Git Summary fallback from file_paths / recent_commits
    if file_paths or recent_commits:
        files_list = "".join(f"\n  - {p}" for p in file_paths[:10])  # show first 10
        commits_count = f"\n- Recent commits: {len(recent_commits)}" if recent_commits else ""
        git_summary = (
            "## Git Summary\n\n"
            + f"- Modified files: {len(file_paths)}"
            + files_list
            + commits_count
        )
        parts.append(git_summary)
    # <<< END INSERTION

    body = frontmatter + "\n\n" + "\n\n---\n\n".join(parts) + "\n\n---\n*Generated by Copidock intelligent template system*\n"
    return body


@app.command("thread")
def thread_cmd(
    action: str = typer.Argument(..., help="Action: start"),
    goal: Optional[str] = typer.Argument(None, help="Thread goal"),
    repo: Optional[str] = typer.Option(None, "--repo", help="Repository name"),
    branch: Optional[str] = typer.Option(None, "--branch", help="Branch name"),
    persona: str = typer.Option("senior-backend-dev", "--persona", help="Template persona to use"),
    profile: str = typer.Option(DEFAULT_PROFILE, "--profile", help="Config profile"),
    api: Optional[str] = typer.Option(None, "--api", help="API base URL"),
    json_out: bool = typer.Option(False, "--json", help="JSON output"),
):
    """Thread management"""
    if action == "start":
        if not goal:
            rprint("[red]Goal is required for thread start[/red]")
            raise typer.Exit(1)
        
        # AUTO-DETECT git context if not provided
        if not repo or not branch:
            repo_root = find_repo_root()
            context = auto_detect_context(repo_root)
            
            repo = repo or context.get('repo', 'unknown')
            branch = branch or context.get('branch', 'main')
            
            rprint(f"[dim]Auto-detected: {repo} (branch: {branch})[/dim]")
        thread_start(goal, repo, branch, profile, api, json_out)
    else:
        rprint(f"[red]Unknown action: {action}[/red]")
        raise typer.Exit(1)

@app.command("note")
def note_cmd(
    action: str = typer.Argument(..., help="Action: add"),
    text: Optional[str] = typer.Argument(None, help="Note text"),
    tags: Optional[str] = typer.Option("", "--tags", help="Comma-separated tags"),
    profile: str = typer.Option(DEFAULT_PROFILE, "--profile"),
    api: Optional[str] = typer.Option(None, "--api"),
    json_out: bool = typer.Option(False, "--json"),
):
    """Note management"""
    if action != "add":
        rprint("[red]Only 'add' action supported[/red]")
        raise typer.Exit(1)
        
    if not text:
        rprint("[red]Note text is required[/red]")
        raise typer.Exit(1)
    
    repo_root = find_repo_root()
    state = load_state(repo_root)
    thread_id = state.get("thread_id", "")
    
    api_base, api_key, timeout = resolve_api(profile, api)
    client = CopidockAPI(api_base, api_key, timeout)
    
    tag_list = [t.strip() for t in (tags or "").split(",") if t.strip()]
    
    try:
        data = client.create_note(text, tag_list, thread_id)
        if json_out:
            rprint(data)
        else:
            rprint(f"[green]Note added[/green]: {data['note_id']}")
    except Exception as e:
        rprint(f"[red]Error:[/red] {e}")
        raise typer.Exit(1)
    
def get_persona_specific_options(persona: str) -> Dict:
    """Load persona-specific CLI options dynamically"""
    persona_config = template_loader.load_persona(persona)
    return persona_config.get('cli_parameters', {})

def save_local_artifact(rehydration_content: str, thread_data: Dict) -> str:
    """Save rehydration artifact locally and update manifest"""
    from pathlib import Path
    import json
    from datetime import datetime
    
    # Create rehydrations directory
    rehydrations_dir = Path("copidock/rehydrations")
    rehydrations_dir.mkdir(parents=True, exist_ok=True)
    
    # Generate filename
    timestamp = datetime.now().strftime("%Y%m%d-%H%M%S")
    thread_slug = thread_data.get('goal', 'task').lower().replace(' ', '-')[:20]
    filename = f"{timestamp}-{thread_slug}.md"
    
    # Save artifact
    artifact_path = rehydrations_dir / filename
    artifact_path.write_text(rehydration_content)
    
    # Update manifest
    manifest_path = rehydrations_dir / "index.json"
    manifest = []
    if manifest_path.exists():
        manifest = json.loads(manifest_path.read_text())
    
    manifest.append({
        "filename": filename,
        "timestamp": timestamp,
        "goal": thread_data.get('goal', 'task'),
        "thread_id": thread_data.get('thread_id'),
        "created_at": datetime.now().isoformat()
    })
    
    # Keep only last 10 entries
    manifest = manifest[-10:]
    manifest_path.write_text(json.dumps(manifest, indent=2))
    
    # Update LATEST pointer
    latest_path = rehydrations_dir / "LATEST"
    latest_path.write_text(filename)
    
    return filename

@app.command("snapshot")
def snapshot_cmd(
    action: str = typer.Argument(..., help="Action: create"),
    hydrate: bool = typer.Option(False, "--hydrate", help="Save comprehensive snapshot as markdown to S3"),
    message: Optional[str] = typer.Option("", "--message", help="Snapshot message"),
    auto: bool = typer.Option(False, "--auto", help="Auto-gather git changes"),
    comprehensive: bool = typer.Option(False, "--comprehensive", help="Generate comprehensive rehydration"),
    
    # Enhanced intelligence parameters
    persona: str = typer.Option("senior-backend-dev", "--persona", help="Template persona to use"),
    focus: Optional[str] = typer.Option(None, "--focus", help="What you're working on"),
    output: Optional[str] = typer.Option(None, "--output", help="Expected deliverable"),
    constraints: Optional[str] = typer.Option(None, "--constraints", help="Limitations or requirements"),
    since: Optional[str] = typer.Option(None, "--since", help="Git time range"),

    stage: str = typer.Option("auto", "--stage", help="Project stage: auto, initial, development, maintenance"),
    
    # Interactive and intelligence modes
    interactive: bool = typer.Option(False, "--interactive", help="Interactive mode for missing context"),
    auto_detect: bool = typer.Option(True, "--auto-detect", help="Auto-detect context from git and files"),

    # NEW: Optional CLI polish parameters
#     to be able to do this in the future: 
#     copidock snapshot --comprehensive --include "*.py"
#     copidock snapshot --comprehensive --exclude "node_modules/*,tests/*,build/*"
#     copidock snapshot --comprehensive \
#   --include "api/*.py,services/*.py" \
#   --exclude "scripts/*,migrations/*"

    embed_bytes: int = typer.Option(200000, "--embed-bytes", help="Max bytes to embed in rehydration"),
    include: Optional[str] = typer.Option(None, "--include", help="Glob pattern for files to include"),
    exclude: Optional[str] = typer.Option(None, "--exclude", help="Glob pattern for files to exclude"),
    
    # Existing parameters
    profile: str = typer.Option(DEFAULT_PROFILE, "--profile", help="Config profile"),
    api: Optional[str] = typer.Option(None, "--api", help="API base URL"),
    json_out: bool = typer.Option(False, "--json", help="JSON output"),
):  
    """Create development snapshot with optional stage awareness
    
    Examples:
        copidock snapshot --hydrate
        copidock rehydrate restore LATEST
        copidock snapshot --comprehensive --hydrate --focus "timer logic"
        copidock snapshot --include "*.py" --exclude "test_*"
    """
    

    """Create development snapshot with optional stage awareness"""

    if action != "create":
        rprint("[red]Only 'create' action supported[/red]")
        raise typer.Exit(1)
    
    # Stage detection - ONLY ONE BLOCK
    repo_root = find_repo_root()
    if stage == "auto":
        context = auto_detect_context(repo_root)
        
        if any('README' in f.upper() for f in context.get('modified_files', [])):
            detected_stage = "initial"
            rprint(f"[dim]Auto-detected stage: {detected_stage} (README found in changes)[/dim]")
        else:
            detected_stage = "development"
            rprint(f"[dim]Auto-detected stage: {detected_stage}[/dim]")
    else:
        detected_stage = stage
        rprint(f"[dim]Using stage: {detected_stage}[/dim]")
    
    # Load state
    state = load_state(repo_root)
    thread_id = state.get("thread_id", "")
    
    if not thread_id:
        rprint("[red]No active thread found. Start a thread first.[/red]")
        raise typer.Exit(1)
    
    api_base, api_key, timeout = resolve_api(profile, api)
    client = CopidockAPI(api_base, api_key, timeout)

    # Interactive flow
    if interactive:
        rprint("[blue]üéØ Interactive Snapshot Creation[/blue]")
        rprint()
        
        # Auto-detect context for smart defaults
        context = auto_detect_context(repo_root, since)
        
        # Interactive prompting with smart defaults
        interactive_params = run_interactive_flow(context, persona, focus, output, constraints, detected_stage)
        
        # Use interactive parameters
        focus = interactive_params['focus']
        output = interactive_params['output']
        constraints = interactive_params['constraints']
        persona = interactive_params['persona']
        
        # Show summary and confirm
        if not confirm_snapshot_creation(detected_stage, interactive_params, context):
            rprint("[yellow]Snapshot creation cancelled[/yellow]")
            raise typer.Exit(0)

    # Handle comprehensive mode
    if comprehensive:
        from .gather import gather_comprehensive
        from .synthesis import generate_comprehensive_snapshot
        
        try:
            ctx_for_meta = auto_detect_context(repo_root)
            thread_data = {
            'thread_id': thread_id,
            'goal'   : state.get('goal', 'development task'),
            'repo'   : state.get('repo') or ctx_for_meta.get('repo', ''),
            'branch' : state.get('branch') or ctx_for_meta.get('branch', 'main'),
        }
            
            # Comprehensive gathering
            file_paths, recent_commits, notes = gather_comprehensive(str(repo_root), thread_id)
            
            if not file_paths and detected_stage != "initial":
                rprint("[yellow]No relevant files found for comprehensive snapshot[/yellow]")
                # raise typer.Exit(0)
            
            # Create enhanced context with stage information
            enhanced_context = {
                'focus': focus,
                'output': output, 
                'constraints': constraints,
                'stage': detected_stage,
                'persona': persona
            }
            
            # Generate synthesis sections based on stage
            if detected_stage == "initial":
                empty_file_paths = []
                empty_commits = []
                
                from .synthesis import generate_initial_stage_snapshot
                synth_sections = generate_initial_stage_snapshot(
                    thread_data, enhanced_context, persona, comprehensive=True
                )
                
                file_paths = empty_file_paths
                recent_commits = empty_commits
                
            else:
                from .synthesis import generate_development_stage_snapshot
                synth_sections = generate_development_stage_snapshot(
                    thread_data, file_paths, recent_commits, str(repo_root), persona, enhanced_context
                )
            
            # Hydrate logic for comprehensive mode
            if hydrate:
                files_md = render_files_markdown(Path(repo_root), file_paths)
                rehydration_content = create_rehydration_markdown(
                    thread_data, synth_sections, file_paths, recent_commits, enhanced_context
                )
                if files_md:
                    rehydration_content += "\n\n" + files_md

                filename = save_local_artifact(rehydration_content, thread_data)
                from rich.panel import Panel

                rprint(Panel(
                f"‚úÖ [green]Hydration Artifact Ready[/green]\n"
                f"üìÅ Saved to: [cyan]copidock/rehydrations/{filename}[/cyan]\n"
                f"üîÑ Restore with: [yellow]copidock rehydrate restore LATEST[/yellow]",
                title="Hydration Complete"
                ))

                hydrate_data = client.hydrate_snapshot(thread_id, rehydration_content, {
                    'persona': persona,
                    'focus': focus,
                    'output': output,
                    'constraints': constraints,
                    'stage': detected_stage,
                    'repo': thread_data['repo'],
                    'file_count': len(file_paths),
                    'commit_count': len(recent_commits)
                })
                
                if not json_out:
                    rprint(f"[green]Comprehensive snapshot hydrated to S3[/green]: {hydrate_data['rehydration_id']}")
                    rprint(f"[dim]{'Rich YML template guidance provided' if detected_stage=='initial' else 'Full git analysis included'}[/dim]")
                return

            else:
                # Build inline sources and let the server write the comprehensive snapshot
                inline_sources = []
                for file_path in file_paths:
                    try:
                        full_path = Path(repo_root) / file_path
                        if full_path.exists():
                            content = full_path.read_text(errors='ignore')
                            ext = full_path.suffix.lstrip('.')
                            language = {
                                'py':'python','js':'javascript','ts':'typescript',
                                'tf':'hcl','yml':'yaml','yaml':'yaml',
                                'json':'json','md':'markdown','sh':'bash'
                            }.get(ext,'text')
                            inline_sources.append({
                                'path': file_path,
                                'language': language,
                                'content': content
                            })
                    except Exception:
                        continue

                payload = {
                    'thread_id': thread_id,
                    'stage': detected_stage,
                    'inline_sources': inline_sources,
                    'synth': synth_sections,
                    'message': message,
                    'repo': state.get('repo', ''),
                }

                # Create comprehensive snapshot
                data = client.create_comprehensive_snapshot(payload)
                
                if json_out:
                    rprint(data)
                else:
                    rprint(f"[green]Comprehensive snapshot created[/green]: {data['snapshot_id']}")
                    rprint(f"[dim]Included {len(inline_sources)} files with full synthesis[/dim]")
                
        except Exception as e:
            rprint(f"[red]Error creating comprehensive snapshot:[/red] {e}")
            raise typer.Exit(1)

    # Handle initial stage without comprehensive (plain/empty template)  
    elif detected_stage == "initial":
        from .synthesis import generate_initial_stage_snapshot

        ctx_for_meta = auto_detect_context(repo_root)
        thread_data = {
            'thread_id': thread_id,
            'goal'   : state.get('goal', 'development task'),
            'repo'   : state.get('repo') or ctx_for_meta.get('repo', ''),
            'branch' : state.get('branch') or ctx_for_meta.get('branch', 'main'),
        }
        
        enhanced_context = {
            'focus': focus,
            'output': output, 
            'constraints': constraints,
            'stage': detected_stage,
            'persona': persona
        }
        
        # Call your perfect function with comprehensive=False
        synth_sections = generate_initial_stage_snapshot(
            thread_data, enhanced_context, persona, comprehensive=False
        )
        
        # Complete hydrate logic for plain/empty template
        if hydrate:
            # Create rehydration markdown with empty file/commit arrays
            empty_file_paths = []
            empty_commits = []

            from .gather import keep_if_exists
            identity = keep_if_exists(repo_root, ["README.md", "package.json", ".copidock/state.json"])
            files_md = render_files_markdown(Path(repo_root), identity)

            rehydration_content = create_rehydration_markdown(
                thread_data, synth_sections, empty_file_paths, empty_commits, enhanced_context
            )
            if files_md:
                rehydration_content += "\n\n" + files_md

            filename = save_local_artifact(rehydration_content, thread_data)
            from rich.panel import Panel

            rprint(Panel(
            f"‚úÖ [green]Hydration Artifact Ready[/green]\n"
            f"üìÅ Saved to: [cyan]copidock/rehydrations/{filename}[/cyan]\n"
            f"üîÑ Restore with: [yellow]copidock rehydrate restore LATEST[/yellow]",
            title="Hydration Complete"
            ))

            hydrate_data = client.hydrate_snapshot(thread_id, rehydration_content, {
                'persona': persona,
                'focus': focus,
                'output': output,
                'constraints': constraints,
                'stage': detected_stage,
                'repo': thread_data['repo'],
                'file_count': 0,
                'commit_count': 0
            })
            
            if not json_out:
                rprint(f"[green]Initial stage snapshot hydrated to S3[/green]: {hydrate_data['rehydration_id']}")
                rprint(f"[dim]Empty template structure created for manual customization[/dim]")
            return
        
        # SHOW THE TEMPLATE OUTPUT
        print("\n" + "="*70)
        print("INITIAL STAGE TEMPLATE (EMPTY STRUCTURE)")
        print("="*70)
        for section_name, content in synth_sections.items():
            print(f"\n {section_name.replace('_', ' ').title()}")
            print("-" * 50)
            print(content)
            print("")
        print("="*70)
        print("Empty template structure ready for customization!")
        print("="*70 + "\n")
        
        # Create empty snapshot
        data = client.create_snapshot(thread_id, [], f"Initial stage template: {message}")
        
        if json_out:
            rprint(data)
        else:
            rprint(f"[green]Initial stage snapshot created[/green]: {data['snapshot_id']}")
            rprint(f"[dim]Empty structure ready for customization[/dim]")

    # Handle auto mode
    elif auto:
        from .gather import build_smart_paths
        
        try:
            file_paths, stats = build_smart_paths(str(repo_root))
            
            if not file_paths:
                rprint("[yellow]No relevant changed files found[/yellow]")
                raise typer.Exit(0)
            
            # Show what we're including
            if not json_out:
                rprint(f"[green]Auto-detected {stats['final_count']} files[/green]")
                rprint(f"[dim]Filtered: {stats['total_changed']} ‚Üí {stats['after_filtering']} ‚Üí {stats['final_count']} files[/dim]")
                for path in file_paths[:5]:  # Show first 5
                    rprint(f"[dim]  ‚Ä¢ {path}[/dim]")
                if len(file_paths) > 5:
                    rprint(f"[dim]  ... and {len(file_paths) - 5} more[/dim]")
            
            # Create regular snapshot
            data = client.create_snapshot(thread_id, file_paths, message)
            
            if json_out:
                rprint(data)
            else:
                rprint(f"[green]Snapshot created[/green]: {data['snapshot_id']}")
                rprint(f"[dim]Included {len(file_paths)} files[/dim]")
        
        except Exception as e:
            rprint(f"[red]Error gathering files:[/red] {e}")
            raise typer.Exit(1)
    
    else:
        # Manual mode - use empty paths
        try:
            data = client.create_snapshot(thread_id, [], message)
            if json_out:
                rprint(data)
            else:
                rprint(f"[green]Snapshot created[/green]: {data['snapshot_id']}")
        except Exception as e:
            rprint(f"[red]Error:[/red] {e}")
            raise typer.Exit(1)

@app.command("rehydrate")
def rehydrate_cmd(
    action: str = typer.Argument(..., help="Action: 'restore' or 'list'"),
    rehydration_id: Optional[str] = typer.Argument(None, help="Rehydration ID or 'LATEST'"),
    profile: str = typer.Option(DEFAULT_PROFILE, "--profile", help="Config profile"),
    api: Optional[str] = typer.Option(None, "--api", help="API base URL"),
    json_out: bool = typer.Option(False, "--json", help="JSON output"),
    save_local: bool = typer.Option(True, "--save-local/--no-save-local", help="Save to local rehydrations folder"),
):
    """Rehydrate from saved artifacts or list available rehydrations"""
    
    if action == "list":
        list_rehydrations()
        return
    elif action == "restore":
        if not rehydration_id:
            typer.echo("Error: rehydration_id required for restore action")
            raise typer.Exit(1)
        restore_rehydration(rehydration_id)
    else:
        typer.echo(f"Error: Unknown action '{action}'. Use 'restore' or 'list'")
        raise typer.Exit(1)

def list_rehydrations():
    """List available local rehydrations"""
    from pathlib import Path
    import json
    from rich.table import Table
    from rich.console import Console
    
    console = Console()
    rehydrations_dir = Path("copidock/rehydrations")
    manifest_path = rehydrations_dir / "index.json"
    
    if not manifest_path.exists():
        console.print("No rehydrations found.")
        return
    
    manifest = json.loads(manifest_path.read_text())
    
    table = Table(title="Available Rehydrations")
    table.add_column("ID", style="cyan")
    table.add_column("Goal", style="green")
    table.add_column("Created", style="yellow")
    
    for entry in reversed(manifest):  # Show newest first
        table.add_row(
            entry["filename"].replace(".md", ""),
            entry["goal"],
            entry["created_at"][:19]  # Strip microseconds
        )
    
    console.print(table)
    console.print(f"\nüí° Use: [bold]copidock rehydrate restore LATEST[/bold]")

def restore_rehydration(rehydration_id: str):
    """Restore from local artifact and refresh local thread context"""
    from pathlib import Path
    import json

    rehydrations_dir = Path("copidock/rehydrations")

    if rehydration_id == "LATEST":
        latest_path = rehydrations_dir / "LATEST"
        if not latest_path.exists():
            typer.echo("No LATEST rehydration found.")
            raise typer.Exit(1)
        rehydration_id = latest_path.read_text().strip()

    if not rehydration_id.endswith(".md"):
        rehydration_id += ".md"

    artifact_path = rehydrations_dir / rehydration_id
    if not artifact_path.exists():
        typer.echo(f"Rehydration artifact not found: {rehydration_id}")
        raise typer.Exit(1)

    content = artifact_path.read_text()

    # --- Minimal front-matter parse for thread context ---
    thread_id = None
    goal = None
    persona = None
    for line in content.splitlines():
        if line.startswith("thread_id:"):
            thread_id = line.split(":", 1)[1].strip()
        elif line.startswith("goal:"):
            goal = line.split(":", 1)[1].strip().strip('"')
        elif line.startswith("persona:"):
            persona = line.split(":", 1)[1].strip()
        elif line.strip() == "---":
            # stop after front-matter block
            break

    # --- Refresh local .copidock/state.json if valid context found ---
    try:
        repo_root = find_repo_root()
        state = load_state(repo_root)
        if thread_id:
            state["thread_id"] = thread_id
        if goal:
            state["goal"] = goal
        if persona:
            state["persona"] = persona
        save_state(repo_root, state)
        rprint(f"[green]Local state refreshed[/green] (thread: {thread_id}, goal: {goal})")
    except Exception:
        rprint("[yellow]‚ö†Ô∏è Unable to update local state (non-fatal)[/yellow]")

    # --- Show restored content ---
    from rich.panel import Panel
    rprint(Panel(
        f"Rehydrated: [cyan]{rehydration_id}[/cyan]\n"
        f"Thread: {thread_id or 'unknown'}\nGoal: {goal or 'N/A'}\nPersona: {persona or 'N/A'}",
        title="üåÄ Context Restored"
    ))
    rprint(content)

    
if __name__ == "__main__":
    app()