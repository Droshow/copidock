import typer
import json
from typing import Optional, Dict
from rich import print as rprint
from pathlib import Path
from datetime import datetime

from ..templates.loader import template_loader
from .commands.thread import thread_start
from .api import CopidockAPI, resolve_api
from ..config.config import find_repo_root, load_state, save_state, DEFAULT_PROFILE

# NEW: Import interactive functions
from ..interactive.detection import auto_detect_context
from ..interactive.flow import run_interactive_flow, confirm_snapshot_creation

app = typer.Typer(add_completion=False, help="Copidock CLI - Serverless note management")

def create_rehydration_markdown(thread_data: Dict, synth_sections: Dict, file_paths: list, recent_commits: list, enhanced_context: Dict) -> str:
    created_at = datetime.utcnow().isoformat() + "Z"
    thread_slug = thread_data.get('goal', 'development-task').lower().replace(' ', '-')
    
    frontmatter = f"""---
thread_id: {thread_data.get('thread_id', '')}
thread_slug: {thread_slug}
snapshot_id: comprehensive-{datetime.utcnow().strftime('%Y%m%d-%H%M%S')}
version: 1
created_at: {created_at}
repo: {thread_data.get('repo', 'unknown')}
branch: {thread_data.get('branch', 'main')}
goal: "{thread_data.get('goal', 'development task')}"
persona: {enhanced_context.get('persona', 'senior-backend-dev')}
focus: "{enhanced_context.get('focus', '')}"
output: "{enhanced_context.get('output', '')}"
constraints: "{enhanced_context.get('constraints', '')}"
file_count: {len(file_paths)}
commit_count: {len(recent_commits)}
---

# Rehydrate: {thread_data.get('goal', 'Development Task')}

## Context Restoration
"""
    # Render all available synth sections (only strings)
    ordered_keys = [
        'operator_instructions',
        'current_state',
        'current_development_state',
        'decisions_constraints',
        'technical_approach',
        'development_priorities',
        'open_questions',
        'next_steps',
    ]
    seen = set()
    parts = []

    for k in ordered_keys:
        v = synth_sections.get(k)
        if isinstance(v, str) and v.strip():
            parts.append(v.strip())
            seen.add(k)

    for k, v in synth_sections.items():
        if k in seen:
            continue
        if isinstance(v, str) and v.strip():
            parts.append(v.strip())

    # >>> INSERTED: Git Summary fallback from file_paths / recent_commits
    if file_paths or recent_commits:
        files_list = "".join(f"\n  - {p}" for p in file_paths[:10])  # show first 10
        commits_count = f"\n- Recent commits: {len(recent_commits)}" if recent_commits else ""
        parts.append(
            "## Git Summary\n\n"
            f"- Modified files: {len(file_paths)}"
            f"{files_list}"
            f"{commits_count}"
        )
    # <<< END INSERTION

    body = frontmatter + "\n\n" + "\n\n---\n\n".join(parts) + "\n\n---\n*Generated by Copidock intelligent template system*\n"
    return body


@app.command("thread")
def thread_cmd(
    action: str = typer.Argument(..., help="Action: start"),
    goal: Optional[str] = typer.Argument(None, help="Thread goal"),
    repo: Optional[str] = typer.Option(None, "--repo", help="Repository name"),
    branch: Optional[str] = typer.Option(None, "--branch", help="Branch name"),
    persona: str = typer.Option("senior-backend-dev", "--persona", help="Template persona to use"),
    profile: str = typer.Option(DEFAULT_PROFILE, "--profile", help="Config profile"),
    api: Optional[str] = typer.Option(None, "--api", help="API base URL"),
    json_out: bool = typer.Option(False, "--json", help="JSON output"),
):
    """Thread management"""
    if action == "start":
        if not goal:
            rprint("[red]Goal is required for thread start[/red]")
            raise typer.Exit(1)
        
        # AUTO-DETECT git context if not provided
        if not repo or not branch:
            repo_root = find_repo_root()
            context = auto_detect_context(repo_root)
            
            repo = repo or context.get('repo', 'unknown')
            branch = branch or context.get('branch', 'main')
            
            rprint(f"[dim]Auto-detected: {repo} (branch: {branch})[/dim]")
        thread_start(goal, repo, branch, profile, api, json_out)
    else:
        rprint(f"[red]Unknown action: {action}[/red]")
        raise typer.Exit(1)

@app.command("note")
def note_cmd(
    action: str = typer.Argument(..., help="Action: add"),
    text: Optional[str] = typer.Argument(None, help="Note text"),
    tags: Optional[str] = typer.Option("", "--tags", help="Comma-separated tags"),
    profile: str = typer.Option(DEFAULT_PROFILE, "--profile"),
    api: Optional[str] = typer.Option(None, "--api"),
    json_out: bool = typer.Option(False, "--json"),
):
    """Note management"""
    if action != "add":
        rprint("[red]Only 'add' action supported[/red]")
        raise typer.Exit(1)
        
    if not text:
        rprint("[red]Note text is required[/red]")
        raise typer.Exit(1)
    
    repo_root = find_repo_root()
    state = load_state(repo_root)
    thread_id = state.get("thread_id", "")
    
    api_base, api_key, timeout = resolve_api(profile, api)
    client = CopidockAPI(api_base, api_key, timeout)
    
    tag_list = [t.strip() for t in (tags or "").split(",") if t.strip()]
    
    try:
        data = client.create_note(text, tag_list, thread_id)
        if json_out:
            rprint(data)
        else:
            rprint(f"[green]Note added[/green]: {data['note_id']}")
    except Exception as e:
        rprint(f"[red]Error:[/red] {e}")
        raise typer.Exit(1)
    
def get_persona_specific_options(persona: str) -> Dict:
    """Load persona-specific CLI options dynamically"""
    persona_config = template_loader.load_persona(persona)
    return persona_config.get('cli_parameters', {})

@app.command("snapshot")
def snapshot_cmd(
    action: str = typer.Argument(..., help="Action: create"),
    hydrate: bool = typer.Option(False, "--hydrate", help="Save comprehensive snapshot as markdown to S3"),
    mode: str = typer.Option("auto", "--mode", help="Mode: auto, comprehensive, manual"),
    message: Optional[str] = typer.Option("", "--message", help="Snapshot message"),
    auto: bool = typer.Option(False, "--auto", help="Auto-gather git changes"),
    comprehensive: bool = typer.Option(False, "--comprehensive", help="Generate comprehensive rehydration"),
    
    # Enhanced intelligence parameters
    persona: str = typer.Option("senior-backend-dev", "--persona", help="Template persona to use"),
    focus: Optional[str] = typer.Option(None, "--focus", help="What you're working on"),
    output: Optional[str] = typer.Option(None, "--output", help="Expected deliverable"),
    constraints: Optional[str] = typer.Option(None, "--constraints", help="Limitations or requirements"),
    since: Optional[str] = typer.Option(None, "--since", help="Git time range"),

    stage: str = typer.Option("auto", "--stage", help="Project stage: auto, initial, development, maintenance"),
    
    # Interactive and intelligence modes
    interactive: bool = typer.Option(False, "--interactive", help="Interactive mode for missing context"),
    auto_detect: bool = typer.Option(True, "--auto-detect", help="Auto-detect context from git and files"),
    
    # Existing parameters
    profile: str = typer.Option(DEFAULT_PROFILE, "--profile", help="Config profile"),
    api: Optional[str] = typer.Option(None, "--api", help="API base URL"),
    json_out: bool = typer.Option(False, "--json", help="JSON output"),
):  
    """Create development snapshot with optional stage awareness"""

    if action != "create":
        rprint("[red]Only 'create' action supported[/red]")
        raise typer.Exit(1)
    
    # Stage detection - ONLY ONE BLOCK
    repo_root = find_repo_root()
    if stage == "auto":
        context = auto_detect_context(repo_root)
        
        if any('README' in f.upper() for f in context.get('modified_files', [])):
            detected_stage = "initial"
            rprint(f"[dim]Auto-detected stage: {detected_stage} (README found in changes)[/dim]")
        else:
            detected_stage = "development"
            rprint(f"[dim]Auto-detected stage: {detected_stage}[/dim]")
    else:
        detected_stage = stage
        rprint(f"[dim]Using stage: {detected_stage}[/dim]")
    
    # Load state
    state = load_state(repo_root)
    thread_id = state.get("thread_id", "")
    
    if not thread_id:
        rprint("[red]No active thread found. Start a thread first.[/red]")
        raise typer.Exit(1)
    
    api_base, api_key, timeout = resolve_api(profile, api)
    client = CopidockAPI(api_base, api_key, timeout)

    # Interactive flow
    if interactive:
        rprint("[blue]üéØ Interactive Snapshot Creation[/blue]")
        rprint()
        
        # Auto-detect context for smart defaults
        context = auto_detect_context(repo_root, since)
        
        # Interactive prompting with smart defaults
        interactive_params = run_interactive_flow(context, persona, focus, output, constraints, detected_stage)
        
        # Use interactive parameters
        focus = interactive_params['focus']
        output = interactive_params['output']
        constraints = interactive_params['constraints']
        persona = interactive_params['persona']
        
        # Show summary and confirm
        if not confirm_snapshot_creation(detected_stage, interactive_params, context):
            rprint("[yellow]Snapshot creation cancelled[/yellow]")
            raise typer.Exit(0)

    # Handle comprehensive mode
    if comprehensive:
        from .gather import gather_comprehensive
        from .synthesis import generate_comprehensive_snapshot
        
        try:
            ctx_for_meta = auto_detect_context(repo_root)
            # Get thread data for synthesis
            thread_data = {
                'thread_id': thread_id,
                'goal': state.get('goal', 'development task'),
                'repo': state.get('repo', ''),
                'branch': state.get('branch') or ctx_for_meta.get('branch', 'main'),
                
            }
            
            # Comprehensive gathering
            file_paths, recent_commits, notes = gather_comprehensive(str(repo_root), thread_id)
            
            if not file_paths and detected_stage != "initial":
                rprint("[yellow]No relevant files found for comprehensive snapshot[/yellow]")
                raise typer.Exit(0)
            
            # Create enhanced context with stage information
            enhanced_context = {
                'focus': focus,
                'output': output, 
                'constraints': constraints,
                'stage': detected_stage,
                'persona': persona
            }
            
            # Generate synthesis sections based on stage
            if detected_stage == "initial":
                empty_file_paths = []
                empty_commits = []
                
                from .synthesis import generate_initial_stage_snapshot
                synth_sections = generate_initial_stage_snapshot(
                    thread_data, enhanced_context, persona, comprehensive=True
                )
                
                file_paths = empty_file_paths
                recent_commits = empty_commits
                
            else:
                from .synthesis import generate_development_stage_snapshot
                synth_sections = generate_development_stage_snapshot(
                    thread_data, file_paths, recent_commits, str(repo_root), persona, enhanced_context
                )
            
            # Hydrate logic for comprehensive mode
            if hydrate:
                markdown_content = create_rehydration_markdown(
                    thread_data, synth_sections, file_paths, recent_commits, enhanced_context
                )

                hydrate_data = client.hydrate_snapshot(thread_id, markdown_content, {
                    'persona': persona,
                    'focus': focus,
                    'output': output,
                    'constraints': constraints,
                    'stage': detected_stage,
                    'repo': state.get('repo', ''),
                    'file_count': len(file_paths),
                    'commit_count': len(recent_commits)
                })
                
                if not json_out:
                    rprint(f"[green]Comprehensive snapshot hydrated to S3[/green]: {hydrate_data['rehydration_id']}")
                    rprint(f"[dim]{'Rich YML template guidance provided' if detected_stage=='initial' else 'Full git analysis included'}[/dim]")
                return

            else:
                # Build inline sources and let the server write the comprehensive snapshot
                inline_sources = []
                for file_path in file_paths:
                    try:
                        full_path = Path(repo_root) / file_path
                        if full_path.exists():
                            content = full_path.read_text(errors='ignore')
                            ext = full_path.suffix.lstrip('.')
                            language = {
                                'py':'python','js':'javascript','ts':'typescript',
                                'tf':'hcl','yml':'yaml','yaml':'yaml',
                                'json':'json','md':'markdown','sh':'bash'
                            }.get(ext,'text')
                            inline_sources.append({
                                'path': file_path,
                                'language': language,
                                'content': content
                            })
                    except Exception:
                        continue

                payload = {
                    'thread_id': thread_id,
                    'stage': detected_stage,
                    'inline_sources': inline_sources,
                    'synth': synth_sections,
                    'message': message,
                    'repo': state.get('repo', ''),
                }

                # Create comprehensive snapshot
                data = client.create_comprehensive_snapshot(payload)
                
                if json_out:
                    rprint(data)
                else:
                    rprint(f"[green]Comprehensive snapshot created[/green]: {data['snapshot_id']}")
                    rprint(f"[dim]Included {len(inline_sources)} files with full synthesis[/dim]")
                
        except Exception as e:
            rprint(f"[red]Error creating comprehensive snapshot:[/red] {e}")
            raise typer.Exit(1)

    # Handle initial stage without comprehensive (plain/empty template)  
    elif detected_stage == "initial":
        from .synthesis import generate_initial_stage_snapshot
        ctx_for_meta = auto_detect_context(repo_root)
        
        thread_data = {
            'thread_id': thread_id,
            'goal': state.get('goal', 'development task'),
            'repo': state.get('repo', ''),
            'branch': state.get('branch') or ctx_for_meta.get('branch', 'main'),
        }
        
        enhanced_context = {
            'focus': focus,
            'output': output, 
            'constraints': constraints,
            'stage': detected_stage,
            'persona': persona
        }
        
        # Call your perfect function with comprehensive=False
        synth_sections = generate_initial_stage_snapshot(
            thread_data, enhanced_context, persona, comprehensive=False
        )
        
        # Complete hydrate logic for plain/empty template
        if hydrate:
            # Create rehydration markdown with empty file/commit arrays
            empty_file_paths = []
            empty_commits = []
            
            markdown_content = create_rehydration_markdown(
                thread_data, synth_sections, empty_file_paths, empty_commits, enhanced_context
            )

            hydrate_data = client.hydrate_snapshot(thread_id, markdown_content, {
                'persona': persona,
                'focus': focus,
                'output': output,
                'constraints': constraints,
                'stage': detected_stage,
                'repo' : state.get('repo',''),
                'file_count': 0,
                'commit_count': 0
            })
            
            if not json_out:
                rprint(f"[green]Initial stage snapshot hydrated to S3[/green]: {hydrate_data['rehydration_id']}")
                rprint(f"[dim]Empty template structure created for manual customization[/dim]")
            return
        
        # SHOW THE TEMPLATE OUTPUT
        print("\n" + "="*70)
        print("INITIAL STAGE TEMPLATE (EMPTY STRUCTURE)")
        print("="*70)
        for section_name, content in synth_sections.items():
            print(f"\n {section_name.replace('_', ' ').title()}")
            print("-" * 50)
            print(content)
            print("")
        print("="*70)
        print("Empty template structure ready for customization!")
        print("="*70 + "\n")
        
        # Create empty snapshot
        data = client.create_snapshot(thread_id, [], f"Initial stage template: {message}")
        
        if json_out:
            rprint(data)
        else:
            rprint(f"[green]Initial stage snapshot created[/green]: {data['snapshot_id']}")
            rprint(f"[dim]Empty structure ready for customization[/dim]")

    # Handle auto mode
    elif auto:
        from .gather import build_smart_paths
        
        try:
            file_paths, stats = build_smart_paths(str(repo_root))
            
            if not file_paths:
                rprint("[yellow]No relevant changed files found[/yellow]")
                raise typer.Exit(0)
            
            # Show what we're including
            if not json_out:
                rprint(f"[green]Auto-detected {stats['final_count']} files[/green]")
                rprint(f"[dim]Filtered: {stats['total_changed']} ‚Üí {stats['after_filtering']} ‚Üí {stats['final_count']} files[/dim]")
                for path in file_paths[:5]:  # Show first 5
                    rprint(f"[dim]  ‚Ä¢ {path}[/dim]")
                if len(file_paths) > 5:
                    rprint(f"[dim]  ... and {len(file_paths) - 5} more[/dim]")
            
            # Create regular snapshot
            data = client.create_snapshot(thread_id, file_paths, message)
            
            if json_out:
                rprint(data)
            else:
                rprint(f"[green]Snapshot created[/green]: {data['snapshot_id']}")
                rprint(f"[dim]Included {len(file_paths)} files[/dim]")
        
        except Exception as e:
            rprint(f"[red]Error gathering files:[/red] {e}")
            raise typer.Exit(1)
    
    else:
        # Manual mode - use empty paths
        try:
            data = client.create_snapshot(thread_id, [], message)
            if json_out:
                rprint(data)
            else:
                rprint(f"[green]Snapshot created[/green]: {data['snapshot_id']}")
        except Exception as e:
            rprint(f"[red]Error:[/red] {e}")
            raise typer.Exit(1)


@app.command("rehydrate")
def rehydrate_cmd(
    action: str = typer.Argument(..., help="Action: restore"),
    rehydration_id: Optional[str] = typer.Argument(None, help="Rehydration ID (from --hydrate)"),
    profile: str = typer.Option(DEFAULT_PROFILE, "--profile", help="Config profile"),
    api: Optional[str] = typer.Option(None, "--api", help="API base URL"),
    json_out: bool = typer.Option(False, "--json", help="JSON output"),
    save_local: bool = typer.Option(True, "--save-local/--no-save-local", help="Save to local rehydrations folder"),
):
    """Rehydrate from comprehensive markdown snapshot"""
    if action != "restore":
        rprint("[red]Error: Only 'restore' action is supported[/red]")
        raise typer.Exit(1)
    
    if not rehydration_id:
        rprint("[red]Error: rehydration_id is required[/red]")
        raise typer.Exit(1)
    
    repo_root = find_repo_root()
    api_base, api_key, timeout = resolve_api(profile, api)
    client = CopidockAPI(api_base, api_key, timeout)
    
    try:
        # Get the rehydration data from API
        rehydration_data = client.rehydrate_from_markdown(rehydration_id)
        
        # Extract the markdown content and metadata
        markdown_content = rehydration_data.get('markdown_content', '')
        metadata = rehydration_data.get('metadata', {})
        
        # Create local rehydrations directory
        rehydrations_dir = Path('copidock/rehydrations')
        rehydrations_dir.mkdir(parents=True, exist_ok=True)
        
        # Generate filename with timestamp from metadata or current time
        timestamp = metadata.get('created_at', datetime.now().strftime('%Y%m%d-%H%M%S'))
        if 'T' in timestamp:  # Convert ISO format to simple format
            timestamp = datetime.fromisoformat(timestamp.replace('Z', '+00:00')).strftime('%Y%m%d-%H%M%S')
        
        filename = f"{rehydration_id}-{timestamp}.md"
        file_path = rehydrations_dir / filename
        
        # Save the markdown content locally
        if save_local:
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(markdown_content)
            
            rprint(f"[green]‚úÖ Rehydration saved to: {file_path}[/green]")
        
        # Update local state with rehydrated context
        state = load_state(repo_root)
        state["thread_id"] = rehydration_data.get("thread_id", "")
        state["goal"] = rehydration_data.get("goal", "")
        state["persona"] = rehydration_data.get("persona", "senior-backend-dev")
        save_state(repo_root, state)
        
        # Display context information
        thread_id = rehydration_data.get('thread_id', 'Unknown')
        goal = rehydration_data.get('goal', '')
        focus = metadata.get('focus', '')
        
        rprint(f"[blue]Context rehydrated from comprehensive snapshot[/blue]")
        rprint(f"[blue]Thread ID: {thread_id}[/blue]")
        rprint(f"[blue]Goal: {goal}[/blue]") 
        rprint(f"[blue]Focus: {focus}[/blue]")
        
        if save_local:
            rprint(f"[green]üìÅ File saved: ./copidock/rehydrations/{filename}[/green]")
        
        # Display the full content (or summary)
        if not json_out:
            rprint("\n" + "="*70)
            rprint("REHYDRATED CONTEXT")
            rprint("="*70)
            rprint(markdown_content)
        else:
            print(json.dumps({
                'rehydration_id': rehydration_id,
                'thread_id': thread_id,
                'file_path': str(file_path) if save_local else None,
                'metadata': metadata,
                'markdown_content': markdown_content
            }, indent=2))
            
    except Exception as e:
        rprint(f"[red]Error rehydrating: {str(e)}[/red]")
        raise typer.Exit(1)
    
if __name__ == "__main__":
    app()